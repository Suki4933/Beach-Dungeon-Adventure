#include <SFML/Graphics.hpp>
#include <vector>
#include <memory>
#include <string>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <cmath>
#include <windows.h> // ç”¨äº MessageBoxA

using namespace sf;

 String toSfString(const std::string& str) {
    return String::fromUtf8(str.begin(), str.end());
}

static void setSpriteCover(Sprite& sprite, const Texture& texture, const Vector2f& targetSize) {
    sprite.setTexture(texture, true);

    const Vector2u texSize = texture.getSize();
    if (texSize.x == 0 || texSize.y == 0 || targetSize.x <= 0.f || targetSize.y <= 0.f) {
        return;
    }

    const float targetRatio = targetSize.x / targetSize.y;
    const float texRatio = static_cast<float>(texSize.x) / static_cast<float>(texSize.y);

    IntRect rect(0, 0, static_cast<int>(texSize.x), static_cast<int>(texSize.y));

    if (texRatio > targetRatio) {
        const int newW = static_cast<int>(std::lround(static_cast<float>(texSize.y) * targetRatio));
        const int x = std::max(0, (static_cast<int>(texSize.x) - newW) / 2);
        rect = IntRect(x, 0, std::min(newW, static_cast<int>(texSize.x)), static_cast<int>(texSize.y));
    } else if (texRatio < targetRatio) {
        int newH = static_cast<int>(std::lround(static_cast<float>(texSize.x) / targetRatio));
        newH = std::min(newH, static_cast<int>(texSize.y));
        rect = IntRect(0, 0, static_cast<int>(texSize.x), newH);
    }

    sprite.setTextureRect(rect);
    sprite.setPosition(0.f, 0.f);
    sprite.setScale(targetSize.x / static_cast<float>(rect.width), targetSize.y / static_cast<float>(rect.height));
}

static void setSpriteCoverTopCrop(Sprite& sprite, const Texture& texture, const Vector2f& targetSize, float heightFraction) {
    sprite.setTexture(texture, true);

    const Vector2u texSize = texture.getSize();
    if (texSize.x == 0 || texSize.y == 0 || targetSize.x <= 0.f || targetSize.y <= 0.f) {
        return;
    }

    heightFraction = std::clamp(heightFraction, 0.1f, 1.0f);
    const int cropH = std::max(1, static_cast<int>(std::lround(static_cast<float>(texSize.y) * heightFraction)));
    const float targetRatio = targetSize.x / targetSize.y;

    int rectW = static_cast<int>(texSize.x);
    int rectH = cropH;
    int rectX = 0;
    int rectY = 0;

    const float candidateRatio = static_cast<float>(rectW) / static_cast<float>(rectH);
    if (candidateRatio > targetRatio) {
        const int newW = std::max(1, static_cast<int>(std::lround(static_cast<float>(rectH) * targetRatio)));
        rectX = std::max(0, (rectW - newW) / 2);
        rectW = std::min(newW, rectW);
    } else if (candidateRatio < targetRatio) {
        const int newH = std::max(1, static_cast<int>(std::lround(static_cast<float>(rectW) / targetRatio)));
        rectH = std::min(newH, rectH);
    }

    sprite.setTextureRect(IntRect(rectX, rectY, rectW, rectH));
    sprite.setPosition(0.f, 0.f);
    sprite.setScale(targetSize.x / static_cast<float>(rectW), targetSize.y / static_cast<float>(rectH));
}

static bool loadTextureKeyWhiteAndCrop(Texture& texture, IntRect& outRect, const std::string& path, Uint8 bgBrightnessThreshold = 210, Uint8 bgChromaThreshold = 25) {
    Image img;
    if (!img.loadFromFile(path)) {
        return false;
    }

    const Vector2u size = img.getSize();
    if (size.x == 0 || size.y == 0) {
        outRect = IntRect(0, 0, 0, 0);
        return texture.loadFromImage(img);
    }

    unsigned int minX = size.x;
    unsigned int minY = size.y;
    unsigned int maxX = 0;
    unsigned int maxY = 0;
    bool found = false;

    for (unsigned int y = 0; y < size.y; ++y) {
        for (unsigned int x = 0; x < size.x; ++x) {
            Color c = img.getPixel(x, y);
            if (c.a == 0) {
                continue;
            }

            const Uint8 mx = std::max({c.r, c.g, c.b});
            const Uint8 mn = std::min({c.r, c.g, c.b});
            const Uint8 chroma = static_cast<Uint8>(mx - mn);
            const Uint8 brightness = static_cast<Uint8>((static_cast<unsigned int>(c.r) + static_cast<unsigned int>(c.g) + static_cast<unsigned int>(c.b)) / 3u);
            const bool isBg = (brightness >= bgBrightnessThreshold) && (chroma <= bgChromaThreshold);

            if (isBg) {
                c.a = 0;
                img.setPixel(x, y, c);
                continue;
            }

            found = true;
            minX = std::min(minX, x);
            minY = std::min(minY, y);
            maxX = std::max(maxX, x);
            maxY = std::max(maxY, y);
        }
    }

    if (!found) {
        outRect = IntRect(0, 0, static_cast<int>(size.x), static_cast<int>(size.y));
    } else {
        const int left = static_cast<int>(minX);
        const int top = static_cast<int>(minY);
        const int width = static_cast<int>(maxX - minX + 1);
        const int height = static_cast<int>(maxY - minY + 1);
        outRect = IntRect(left, top, width, height);
    }

    if (!texture.loadFromImage(img)) {
        return false;
    }
    texture.setSmooth(true);
    return true;
}

// ============================================================================
// [1. Base Character Class] â€” Encapsulates health, damage, and health bar rendering.
// ============================================================================
class Character {
protected:
    std::string name;
    int hp, maxHp;
    int attack;
    int defense;

public:
    Character(const std::string& n, int h, int a, int d)
        : name(n), hp(h), maxHp(h), attack(a), defense(d) {}

    virtual ~Character() = default;

 
    void drawHP(RenderWindow& window, float x, float y, Color barColor, const Font& font) const {
        // background black bar
        RectangleShape bg(Vector2f(100, 12));
        bg.setPosition(x, y);
        bg.setFillColor(Color::Black);
        window.draw(bg);

        // Blood volume prospects
        float ratio = 0.0f;
        if (maxHp > 0)
            ratio = static_cast<float>(hp) / maxHp;
        if (ratio < 0) ratio = 0;
        if (ratio > 1) ratio = 1;

        RectangleShape fg(Vector2f(100 * ratio, 12));
        fg.setPosition(x, y);
        fg.setFillColor(barColor);
        window.draw(fg);

        // Name Tag        
Text text(toSfString(name), font, 14);
        text.setPosition(x, y - 20);
        text.setFillColor(Color::White);
        // text.setOutlineColor(Color::Black); // å¯é€‰ï¼šå¢åŠ æè¾¹è®©æ–‡å­—æ›´æ¸…æ™°
        // text.setOutlineThickness(1);
        window.draw(text);
    }

// Affected (considering defense)    
void takeDamage(int damage) {
        int real = std::max(1, damage - defense); 
        hp = std::max(0, hp - real);
    }

    bool isAlive() const { return hp > 0; }
    std::string getName() const { return name; }

// Pure virtual functions: polymorphic skills    
virtual void specialSkill(Character& target) = 0;
};

// ============================================================================
// [2. Monster Base Classes and Specific Monsters] - Inheritance+Polymorphism
// ============================================================================
class Monster : public Character {
public:
    Sprite sprite;

    Monster(const std::string& n, int h, int a, int d) : Character(n, h, a, d) {}

    void setTexture(const Texture& tex, const IntRect& rect) {
        sprite.setTexture(tex, true);
        sprite.setTextureRect(rect);

        const float maxDim = static_cast<float>(std::max(rect.width, rect.height));
        const float desired = 140.0f;
        const float scale = (maxDim > 0.f) ? (desired / maxDim) : 1.0f;
        sprite.setScale(scale, scale);
        sprite.setOrigin(rect.width / 2.0f, rect.height / 2.0f);
    }
};

class Dinosaur : public Monster {
public:
    Dinosaur() : Monster("æé¾™", 60, 25, 5) {}
    void specialSkill(Character& target) override {
        target.takeDamage(15 + rand() % 10); //  
};

    }

class Bird : public Monster {
public:
    Bird() : Monster("é¸Ÿ", 40, 20, 3) {}
    void specialSkill(Character& target) override {
        target.takeDamage(10 + rand() % 8);  
    }
};

class Snake : public Monster {
public:
    Snake() : Monster("è›‡", 50, 18, 7) {}
    void specialSkill(Character& target) override {
        target.takeDamage(12 + rand() % 15); //  
    }
};

// ============================================================================
// ã€3. playerã€‘// ============================================================================
class Player : public Character {
public:
    Sprite sprite;

    Player() : Character("æç›¸å¤·", 100, 20, 10) {}

    void setTexture(const Texture& tex, const IntRect& rect) {
        sprite.setTexture(tex, true);
        sprite.setTextureRect(rect);

        const float maxDim = static_cast<float>(std::max(rect.width, rect.height));
        const float desired = 100.0f;
        const float scale = (maxDim > 0.f) ? (desired / maxDim) : 1.0f;
        sprite.setScale(scale, scale);
        sprite.setOrigin(rect.width / 2.0f, rect.height / 2.0f);
    }

    void normalAttack(Monster& monster) {
        monster.takeDamage(attack + rand() % 10); // 20~29 ä¼¤å®³
    }

    void skillAttack(Monster& monster) {
        monster.takeDamage(attack * 2); // é—ªé¿åå‡»ï¼š40 å›ºå®šä¼¤å®³
    }

    void specialSkill(Character& target) override {        
        target.takeDamage(attack * 2);      
    }    
};

// ============================================================================
// ã€4. Game State Managerã€‘ 
// ============================================================================
enum class GameState {
    MAIN_MENU,
    IN_GAME,
    BATTLE,
    GAME_OVER
};

// ============================================================================
// ã€5. main functionã€‘ 
// ============================================================================
int main() {
    srand(static_cast<unsigned>(time(nullptr)));

    RenderWindow window(VideoMode(800, 600), toSfString("æ²™æ»©åœ°ç‰¢å®è—æ¢é™©"));
    window.setFramerateLimit(60);
    const Vector2f logicalSize(800.f, 600.f);

    // ------------------------------------------------------------------------
    // ã€Resource loadingã€‘
    // ------------------------------------------------------------------------
    
    // 1. åŠ è½½å­—ä½“ï¼ˆåªåŠ è½½ä¸€æ¬¡ï¼ï¼‰
    Font globalFont;
    // ä¼˜å…ˆåŠ è½½æœ¬åœ°å­—ä½“ï¼Œå¤±è´¥åˆ™å°è¯•ç³»ç»Ÿå­—ä½“
    if (!globalFont.loadFromFile("resources/font.ttc") && 
        !globalFont.loadFromFile("C:/Windows/Fonts/msyh.ttc") &&
        !globalFont.loadFromFile("C:/Windows/Fonts/simhei.ttf")) {
        MessageBoxA(nullptr, "æ— æ³•åŠ è½½ä¸­æ–‡å­—ä½“ï¼è¯·ç¡®ä¿ resources/font.ttc å­˜åœ¨ã€‚", "é”™è¯¯", MB_ICONERROR);
        return -1;
    }

    Texture startTex, bgTex, playerTex, dinoTex, birdTex, snakeTex;
    IntRect playerRect, dinoRect, birdRect, snakeRect;

    struct TexLoadItem {
        Texture* tex;
        std::string path;
    };

    const std::vector<TexLoadItem> normalLoads = {
        {&startTex, "resources/start_screen.png"},
        {&bgTex, "resources/background_map.jpg"},
    };

    for (const auto& item : normalLoads) {
        if (!item.tex->loadFromFile(item.path)) {
            std::string msg = "æ— æ³•åŠ è½½å›¾ç‰‡:\n" + item.path;
            MessageBoxA(nullptr, msg.c_str(), "èµ„æºåŠ è½½å¤±è´¥", MB_ICONERROR);
            return -1;
        }
        item.tex->setSmooth(true);
    }

    if (!loadTextureKeyWhiteAndCrop(playerTex, playerRect, "resources/player.png")) {
        MessageBoxA(nullptr, "æ— æ³•åŠ è½½å›¾ç‰‡:\nresources/player.png", "èµ„æºåŠ è½½å¤±è´¥", MB_ICONERROR);
        return -1;
    }
    if (!loadTextureKeyWhiteAndCrop(dinoTex, dinoRect, "resources/dinosaur.png")) {
        MessageBoxA(nullptr, "æ— æ³•åŠ è½½å›¾ç‰‡:\nresources/dinosaur.png", "èµ„æºåŠ è½½å¤±è´¥", MB_ICONERROR);
        return -1;
    }
    if (!loadTextureKeyWhiteAndCrop(birdTex, birdRect, "resources/bird.png")) {
        MessageBoxA(nullptr, "æ— æ³•åŠ è½½å›¾ç‰‡:\nresources/bird.png", "èµ„æºåŠ è½½å¤±è´¥", MB_ICONERROR);
        return -1;
    }
    if (!loadTextureKeyWhiteAndCrop(snakeTex, snakeRect, "resources/snake.png")) {
        MessageBoxA(nullptr, "æ— æ³•åŠ è½½å›¾ç‰‡:\nresources/snake.png", "èµ„æºåŠ è½½å¤±è´¥", MB_ICONERROR);
        return -1;
    }

    Sprite startSprite;
    Sprite background;
    setSpriteCover(startSprite, startTex, logicalSize);
    setSpriteCoverTopCrop(background, bgTex, logicalSize, 0.55f);

    RectangleShape battleOverlay(logicalSize);
    battleOverlay.setFillColor(Color(0, 0, 0, 180));

    // ------------------------------------------------------------------------
    // ã€View initializationã€‘
    // ------------------------------------------------------------------------
    // åˆ›å»ºä¸€ä¸ªå›ºå®šçš„ 800x600 è§†å›¾ï¼Œæ— è®ºçª—å£æ€ä¹ˆè°ƒæ•´ï¼Œæ¸¸æˆé€»è¾‘éƒ½è®¤ä¸ºæ˜¯åœ¨ 800x600 çš„èŒƒå›´å†…
    View gameView(FloatRect(0, 0, logicalSize.x, logicalSize.y));
    window.setView(gameView);

    // ------------------------------------------------------------------------
    // ã€Role initializationã€‘
    // ------------------------------------------------------------------------
    auto createPlayer = [&]() {
        auto p = std::make_unique<Player>();
        p->setTexture(playerTex, playerRect);
        p->sprite.setPosition(100, 300);
        return p;
    };

    auto createMonsters = [&](std::vector<std::unique_ptr<Monster>>& monsters) {
        monsters.clear();

        auto dino = std::make_unique<Dinosaur>();
        dino->setTexture(dinoTex, dinoRect);
        dino->sprite.setPosition(500, 200);

        auto bird = std::make_unique<Bird>();
        bird->setTexture(birdTex, birdRect);
        bird->sprite.setPosition(300, 400);

        auto snake = std::make_unique<Snake>();
        snake->setTexture(snakeTex, snakeRect);
        snake->sprite.setPosition(600, 400);

        monsters.push_back(std::move(dino));
        monsters.push_back(std::move(bird));
        monsters.push_back(std::move(snake));
    };

    auto player = createPlayer();
    std::vector<std::unique_ptr<Monster>> monsters;
    createMonsters(monsters);

    Monster* currentMonster = nullptr;
    GameState state = GameState::MAIN_MENU;
    bool gameWon = false;
    Vector2f savedPlayerPos;
    Vector2f savedMonsterPos;
    bool hasSavedBattlePositions = false;

    // ------------------------------------------------------------------------
    // ã€main loopã€‘
    // ------------------------------------------------------------------------
    while (window.isOpen()) {
        Event event;
        while (window.pollEvent(event)) {
            if (event.type == Event::Closed) {
                window.close();
            }

            // ---------------- çª—å£è°ƒæ•´å¤§å°äº‹ä»¶ (ä¿®å¤ç”»é¢ä¸å…¨é—®é¢˜) ----------------
            if (event.type == Event::Resized) {
                // è®¡ç®—æ–°çš„è§†å£ï¼Œä¿æŒ 800x600 çš„æ¯”ä¾‹ (Letterboxing)
                float windowRatio = event.size.width / (float)event.size.height;
                float viewRatio = 800.0f / 600.0f;
                float sizeX = 1;
                float sizeY = 1;
                float posX = 0;
                float posY = 0;

                if (windowRatio > viewRatio) {
                    sizeX = viewRatio / windowRatio;
                    posX = (1 - sizeX) / 2.f;
                } else {
                    sizeY = windowRatio / viewRatio;
                    posY = (1 - sizeY) / 2.f;
                }

                gameView.setViewport(FloatRect(posX, posY, sizeX, sizeY));
                window.setView(gameView);
            }

            // ---------------- ä¸»èœå•äº‹ä»¶ ----------------
            if (state == GameState::MAIN_MENU) {
                if (event.type == Event::MouseButtonPressed) {
                    // ä¿®å¤ï¼šå°†é¼ æ ‡å±å¹•åæ ‡è½¬æ¢ä¸ºæ¸¸æˆä¸–ç•Œåæ ‡
                    Vector2i mousePixelPos = Mouse::getPosition(window);
                    Vector2f mousePos = window.mapPixelToCoords(mousePixelPos);
                    
                    FloatRect startBtn(300, 300, 200, 50);   // â€œå¼€å§‹æ¸¸æˆâ€æŒ‰é’®åŒºåŸŸ
                    FloatRect exitBtn(300, 400, 200, 50);    // â€œé€€å‡ºâ€æŒ‰é’®åŒºåŸŸ

                    if (startBtn.contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                        state = GameState::IN_GAME;
                    } else if (exitBtn.contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                        window.close();
                    }
                }
            }

            // ---------------- æ¸¸æˆè¿›è¡Œä¸­äº‹ä»¶ ----------------
            if (state == GameState::IN_GAME && event.type == Event::KeyPressed) {
                Vector2f move(0, 0);
                if (event.key.code == Keyboard::W) move.y = -5;
                if (event.key.code == Keyboard::S) move.y = 5;
                if (event.key.code == Keyboard::A) move.x = -5;
                if (event.key.code == Keyboard::D) move.x = 5;

                player->sprite.move(move);

                // æ£€æµ‹æ˜¯å¦ç¢°åˆ°æ€ªç‰©
                FloatRect playerBounds = player->sprite.getGlobalBounds();
                for (auto& m : monsters) {
                    if (m && m->isAlive() && playerBounds.intersects(m->sprite.getGlobalBounds())) {
                        currentMonster = m.get();
                        state = GameState::BATTLE;
                        savedPlayerPos = player->sprite.getPosition();
                        savedMonsterPos = currentMonster->sprite.getPosition();
                        hasSavedBattlePositions = true;

                        player->sprite.setPosition(200.f, 350.f); // æˆ˜æ–—ä½ç½®ï¼ˆä¸­å¿ƒï¼‰
                        currentMonster->sprite.setPosition(600.f, 250.f); // æˆ˜æ–—ä½ç½®ï¼ˆä¸­å¿ƒï¼‰
                        break;
                    }
                }
            }

            // ---------------- æˆ˜æ–—äº‹ä»¶ ----------------
            if (state == GameState::BATTLE && event.type == Event::KeyPressed) {
                if (currentMonster && (event.key.code == Keyboard::Num1 || event.key.code == Keyboard::Num2)) {
                    if (event.key.code == Keyboard::Num1) {
                        player->normalAttack(*currentMonster);
                    } else {
                        player->skillAttack(*currentMonster);
                    }

                    // æ€ªç‰©æ­»äº¡ï¼Ÿ
                    if (!currentMonster->isAlive()) {
                        // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨æ­»äº¡
                        bool allDead = true;
                        for (auto& m : monsters) {
                            if (m && m->isAlive()) {
                                allDead = false;
                                break;
                            }
                        }
                        if (allDead) {
                            gameWon = true;
                            state = GameState::GAME_OVER;
                        } else {
                            state = GameState::IN_GAME;
                        }
                        if (hasSavedBattlePositions) {
                            player->sprite.setPosition(savedPlayerPos);
                            hasSavedBattlePositions = false;
                        }
                        currentMonster = nullptr;
                    } else {
                        // æ€ªç‰©åå‡»
                        currentMonster->specialSkill(*player);
                        if (!player->isAlive()) {
                            gameWon = false;
                            state = GameState::GAME_OVER;
                            if (hasSavedBattlePositions) {
                                player->sprite.setPosition(savedPlayerPos);
                                hasSavedBattlePositions = false;
                            }
                        }
                    }
                }
            }

            // ---------------- æ¸¸æˆç»“æŸäº‹ä»¶ ----------------
            if (state == GameState::GAME_OVER && event.type == Event::MouseButtonPressed) {
                // ä¿®å¤ï¼šå°†é¼ æ ‡å±å¹•åæ ‡è½¬æ¢ä¸ºæ¸¸æˆä¸–ç•Œåæ ‡
                Vector2i mousePixelPos = Mouse::getPosition(window);
                Vector2f mousePos = window.mapPixelToCoords(mousePixelPos);
                
                FloatRect restartBtn(200, 400, 180, 50);   // â€œé‡æ–°å¼€å§‹â€
                FloatRect menuBtn(420, 400, 180, 50);       // â€œè¿”å›ä¸»èœå•â€

                if (restartBtn.contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                    // é‡ç½®æ¸¸æˆ
                    player = createPlayer();
                    createMonsters(monsters);
                    state = GameState::IN_GAME;
                } else if (menuBtn.contains(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y))) {
                    state = GameState::MAIN_MENU;
                }
            }
        }

        // ------------------------------------------------------------------------
        // ã€drawã€‘
        // ------------------------------------------------------------------------
        // ä½¿ç”¨å¤©è“è‰²æ¸…ç©ºçª—å£ï¼Œé˜²æ­¢èƒŒæ™¯å›¾ç¼ºå¤±æ—¶æ˜¾ç¤ºé»‘è‰²æˆ–ç°è‰²
        window.clear(Color(135, 206, 235)); 

        if (state == GameState::MAIN_MENU) {
            window.draw(startSprite);

            // ç»˜åˆ¶èœå•æŒ‰é’®ï¼ˆç”¨æ–‡å­—æ¨¡æ‹Ÿï¼‰
            Text startText(toSfString("å¼€å§‹æ¸¸æˆ"), globalFont, 32);
            startText.setPosition(320, 300);
            startText.setFillColor(Color::White);
            startText.setOutlineColor(Color::Black);
            startText.setOutlineThickness(2);
            window.draw(startText);

            Text exitText(toSfString("é€€å‡ºæ¸¸æˆ"), globalFont, 32);
            exitText.setPosition(320, 400);
            exitText.setFillColor(Color::White);
            exitText.setOutlineColor(Color::Black);
            exitText.setOutlineThickness(2);
            window.draw(exitText);

        } else if (state == GameState::IN_GAME) {
            window.draw(background);
            for (auto& m : monsters) {
                if (m && m->isAlive()) {
                    window.draw(m->sprite);
                }
            }
            window.draw(player->sprite);
            player->drawHP(window, 50, 50, Color::Green, globalFont);

        } else if (state == GameState::BATTLE && currentMonster) {
            window.draw(background);
            window.draw(battleOverlay);
            window.draw(player->sprite);
            window.draw(currentMonster->sprite);

            RectangleShape panel(Vector2f(800.f, 180.f));
            panel.setPosition(0.f, 420.f);
            panel.setFillColor(Color(0, 0, 0, 140));
            window.draw(panel);

            // è¡€æ¡
            currentMonster->drawHP(window, 550, 100, Color::Red, globalFont);
            player->drawHP(window, 100, 100, Color::Green, globalFont);

            // æ“ä½œæç¤º
            Text tip(toSfString("æŒ‰ 1: æ™®é€šæ”»å‡»    æŒ‰ 2: é—ªé¿åå‡»"), globalFont, 20);
            tip.setFillColor(Color::Yellow);
            tip.setPosition(200, 460);
            window.draw(tip);

        } else if (state == GameState::GAME_OVER) {
            window.draw(background);
            window.draw(battleOverlay);
            
            Text result(toSfString(gameWon ? "ğŸ‰ æ­å–œé€šå…³ï¼æç›¸å¤·æ‰¾åˆ°å®è—ï¼" : "ğŸ’€ æç›¸å¤·æˆ˜è´¥...æ¸¸æˆç»“æŸ"), globalFont, 30);
            result.setFillColor(gameWon ? Color::Yellow : Color::Red);
            result.setPosition(150, 200);
            window.draw(result);

            Text restart(toSfString("é‡æ–°å¼€å§‹"), globalFont, 28);
            restart.setPosition(220, 400);
            restart.setFillColor(Color::White);
            window.draw(restart);

            Text menu(toSfString("è¿”å›ä¸»èœå•"), globalFont, 28);
            menu.setPosition(430, 400);
            menu.setFillColor(Color::White);
            window.draw(menu);
        }

        window.display();
    }

    return 0;
}
